#!/usr/bin/env python
# -*- coding:utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
import sys
import warnings
import analysis_data_distribution as ads
# import diffusion_coef_integration as dci
# # import diffusion_coef_aniso as dca
# import pandas as pd
# import observed_data_process as odp
# import generate_fractal_sample as gfs

import os
import subprocess
# Optionally, import logging if you want to use logging instead of print
# import logging
# logging.basicConfig(level=logging.INFO)



def run_cpp_program(exe_path, snapshot_file, N_particles, param1, param2, param3, param4, N_iter):
    """
    Run the precompiled C++ program with the given parameters using subprocess.
    
    Parameters:
        exe_path (str): Full path to the C++ executable (e.g., "/path/to/out.exe").
        snapshot_file (str): Identifier or name for the data set (e.g., "snapshot_fractal").
        N_particles (int): Number of particles (e.g., 10000 up to 1e9).
        param1 (float): First parameter (e.g., 137.0, often total mass or similar).
        param2 (float): Second parameter (e.g., 50.0, often R0 or radius).
        param3 (float): Third parameter (e.g., 1.0, used as a boolean flag in C++ code).
        param4 (float): Fourth parameter (e.g., 1.0, used as a boolean flag in C++ code).
        N_iter (int): Number of iterations for noise (e.g., 0 for none, or a positive integer).
    
    Returns:
        subprocess.CompletedProcess: The result of the executed subprocess, containing 
                                     exit code, stdout, and stderr.
    """
    # Construct the command as a list of strings. Using a list (instead of a single string) 
    # ensures that each argument is properly handled and avoids the need for shell quoting.
    cmd = [
        exe_path,
        snapshot_file,
        str(N_particles),
        str(param1),
        str(param2),
        str(param3),
        str(param4),
        str(N_iter)
    ]
    # Log or print the command for debugging (optional)
    # logging.info(f"Executing command: {' '.join(cmd)}")
    print(f"Executing command: {' '.join(cmd)}")
    
    try:
        # Run the command and capture output and errors
        result = subprocess.run(cmd, capture_output=True, text=True)
    except Exception as e:
        # Handle exceptions such as file not found or execution issues
        print(f"Failed to run {exe_path}: {e}")
        # Re-raise the exception after logging, if desired
        raise

    # Check the return code to determine if the execution was successful
    if result.returncode != 0:
        print(f"Program exited with a non-zero status {result.returncode}.")
    # Print standard output and error output, if any
    if result.stdout:
        print("Program output:\n" + result.stdout)
    if result.stderr:
        print("Program error output:\n" + result.stderr)
    
    return result  # Return the CompletedProcess for further inspection if needed

def process_output_files(snapshot_file):
    """
    Placeholder function to process the output files generated by the C++ program.
    In a real scenario, this function would read and process files (e.g., .txt or .binary)
    produced by the C++ simulation identified by the snapshot_file name.
    
    Parameters:
        snapshot_file (str): The base name used for the output files from the C++ program.
    """
    # Example (to be implemented): read output files like f"{snapshot_file}_Diffur*.txt"
    # and extract relevant data or statistics.
    print(f"(Processing output files for '{snapshot_file}'...)")
    # TODO: implement actual file processing as needed
    pass

# Run the main function when this script is executed
def call_pos():
    
    """Example of running the C++ program with sample parameters."""
    # Sample parameters (these can be adjusted as needed)
    exe_path = "../diffu_r_simple_each/out.exe"           # Path to the C++ executable
    snapshot_file = "snapshot_fractal"      # Example snapshot or scenario name
    N_particles = 10000                     # Example number of particles
    param1 = 137.0                          # Example parameter 1 (e.g., total mass)
    param2 = 50.0                           # Example parameter 2 (e.g., radius)
    param3 = 1.0                            # Example parameter 3 (e.g., flag to generate samples)
    param4 = 1.0                            # Example parameter 4 (e.g., flag to run diffusion calc)
    N_iter = 0                              # Example iterations (0 = no noise, >0 = apply noise)
    
    # Execute the C++ program with the above parameters
    result = run_cpp_program(exe_path, snapshot_file, N_particles, param1, param2, param3, param4, N_iter)
    
    # If the execution was successful, proceed to process the output files (if any)
    if result.returncode == 0:
        process_output_files(snapshot_file)




def run_cpp_program_pos(
    exe_path, snapshot_simulated, N_particles, M_total_set, R0_set, is_by_generating, is_diffu, N_iter, 
    vmean_3_x, vmean_3_y, vmean_3_z, ratio_sigma_xx, ratio_sigma_yy, ratio_sigma_zz, 
    logfile="nohup.out"
):
    """
    Run the precompiled C++ program with the given parameters using subprocess, for veocity samples.
    
    ## an example in the shell
    $ file_snapshot_fractal=snapshot_for_
    $ N_particles=10000
    $ make all;
    $ ./out_vel.exe ${snapshot_simulated} ${N_particles} 137. 50. 1 1 0 0. 0. 0. 8. 6. 1.

    ## to see the print
    $ cd ~/workroom/0prog/proj2/MFRT/data/examples_vel/
    $ rm nohup.out
    $ ps -aux | grep out_vel.exe
    $ tail -f nohup.out
    """
    # Construct the command as a list of strings. Using a list (instead of a single string) 
    # ensures that each argument is properly handled and avoids the need for shell quoting.
    cmd = [
        exe_path, snapshot_simulated, 
        str(N_particles), str(M_total_set), str(R0_set), 
        str(is_by_generating), str(is_diffu), str(N_iter), 
        str(vmean_3_x), str(vmean_3_y), str(vmean_3_z), 
        str(ratio_sigma_xx), str(ratio_sigma_yy), str(ratio_sigma_zz), 
    ]
    print(f"Executing command:\n{' '.join(cmd)}")
    
    # open logfile in append mode
    with open(logfile, "a") as out:
        # proc = subprocess.run(cmd, capture_output=True, text=True)

        # Start the process in its own session (so it won't get SIGHUP)
        proc = subprocess.Popen(
            cmd, 
            stdout=out, 
            stderr=subprocess.STDOUT, 
            preexec_fn=os.setsid  # UNIX only
        )
        # *** BLOCK HERE until the C++ program actually finishes, otherwise it is wrong when reading files ***
        proc.wait()
        # immediately return; the process keeps running in background
        print(f"Launched PID={proc.pid}, logging to {logfile}")
    
    print(f"Run pos, done.")
    return proc

def run_cpp_program_vel(
    exe_path, snapshot_simulated, N_particles, M_total_set, R0_set, is_by_generating, is_diffu, N_iter, 
    vmean_3_x, vmean_3_y, vmean_3_z, ratio_sigma_xx, ratio_sigma_yy, ratio_sigma_zz, 
    logfile="nohup.out"
):
    """
    Run the precompiled C++ program with the given parameters using subprocess, for veocity samples.
    
    ## an example in the shell
    $ file_snapshot_fractal=snapshot_for_
    $ N_particles=10000
    $ make all;
    $ ./out_vel.exe ${snapshot_simulated} ${N_particles} 137. 50. 1 1 0 0. 0. 0. 8. 6. 1.

    ## to see the print
    $ cd ~/workroom/0prog/proj2/MFRT/data/examples_vel/
    $ rm nohup.out
    $ ps -aux | grep out_vel.exe
    $ tail -f nohup.out
    """
    # Construct the command as a list of strings. Using a list (instead of a single string) 
    # ensures that each argument is properly handled and avoids the need for shell quoting.
    cmd = [
        exe_path, snapshot_simulated, 
        str(N_particles), str(M_total_set), str(R0_set), 
        str(is_by_generating), str(is_diffu), str(N_iter), 
        str(vmean_3_x), str(vmean_3_y), str(vmean_3_z), 
        str(ratio_sigma_xx), str(ratio_sigma_yy), str(ratio_sigma_zz), 
    ]
    print(f"Executing command:\n{' '.join(cmd)}")
    
    # open logfile in append mode
    with open(logfile, "a") as out:
        # proc = subprocess.run(cmd, capture_output=True, text=True)

        # Start the process in its own session (so it won't get SIGHUP)
        proc = subprocess.Popen(
            cmd, 
            stdout=out, 
            stderr=subprocess.STDOUT, 
            preexec_fn=os.setsid  # UNIX only
        )
        # *** BLOCK HERE until the C++ program actually finishes, otherwise it is wrong when reading files ***
        proc.wait()
        # immediately return; the process keeps running in background
        print(f"Launched PID={proc.pid}, logging to {logfile}")
    
    print(f"Run vel, done.")
    return proc



if __name__ == "__main__":

    ## an example to run vel
    exe_path = "../diffu_r_simple_each/./out_vel.exe"
    snapshot_simulated = "snapshot_for_"
    N_particles = 10000 #user set
    M_total_set = 137. #user set
    R0_set = 50. #user set
    is_by_generating = 1
    is_diffu = 1
    N_iter = 14 #user set
    vmean_3_x = 0. #user set
    vmean_3_y = 0. #user set
    vmean_3_z = 0. #user set
    ratio_sigma_xx = 8. #user set
    ratio_sigma_yy = 6. #user set
    ratio_sigma_zz = 1. #user set
    run_cpp_program_vel(
        exe_path, snapshot_simulated, N_particles, M_total_set, R0_set, is_by_generating, is_diffu, N_iter, 
        vmean_3_x, vmean_3_y, vmean_3_z, ratio_sigma_xx, ratio_sigma_yy, ratio_sigma_zz
    )
